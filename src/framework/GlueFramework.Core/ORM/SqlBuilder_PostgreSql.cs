using Dapper;
using GlueFramework.Core.Abstractions;
using System.Text;
using static GlueFramework.Core.ORM.SqlBuilderFactory;

namespace GlueFramework.Core.ORM
{
    public class SqlBuilder_PostgreSql<T> : SqlBuilder_Base<T>, ISqlBuilder<T>, ISqlBuilderPartition
        where T : class
    {
        protected override char GetNamePrefix() => '"';

        protected override char GetNameSuffix() => '"';

        protected override string BuildInsertedIdSql()
        {
            // Fallback if some call path still uses it; preferred is INSERT .. RETURNING.
            return "(SELECT LASTVAL())";
        }

        public SqlBuilder_PostgreSql(IDataTablePrefixProvider dataTablePrefixProvider = null)
        {
            Analyze<T>(dataTablePrefixProvider);
        }

        protected override DBTypes GetDbType()
        {
            return DBTypes.POSTGRESQL;
        }

        public override string GetSelectTopRecordsSql(int number)
        {
            return $"Select {GetFieldList()} FROM {TableNameForSql()} limit {number}; ";
        }

        public override string GetQueryTopRecordsSql(int number, string where)
        {
            return $"Select {GetFieldList()} FROM {TableNameForSql()} {where} limit {number}; ";
        }

        protected override string GetSelectByPagerSql(string filter, string orderby, int pageIndex, int pageSize)
        {
            var skip = 0;
            if (pageIndex > 1)
                skip = (pageIndex - 1) * pageSize;

            var fieldList = GetFieldList();
            var sb = new StringBuilder();
            sb.AppendFormat($"SELECT {fieldList} FROM {TableNameForSql()} {filter} {orderby} LIMIT {pageSize} OFFSET {skip}");
            return sb.ToString();
        }

        public string GetSelectByFilterSql(string filter, int recordNumber)
        {
            return $"Select {GetFieldList()} FROM {TableNameForSql()} WHERE {filter} limit {recordNumber}; ";
        }

        public string GetSelectByFilterSql(string filter, int recordNumber, string orderBy)
        {
            return $"Select {GetFieldList()} FROM {TableNameForSql()} WHERE {filter} Order by {orderBy} limit {recordNumber}; ";
        }

        public override string GetInsertAndReturnSql()
        {
            // PostgreSQL: prefer RETURNING so we don't need an extra SELECT.
            var insertSql = GetInsertSql().TrimEnd(';');
            return $"{insertSql} RETURNING {GetFieldList()};";
        }

        public override string GetUpdateAndReturnSql()
        {
            var updateSql = GetUpdateSql().TrimEnd(';');
            return $"{updateSql} RETURNING {GetFieldList()};";
        }

        public override string GetCreateSql()
        {
            // Basic PostgreSQL mapping. Keep it minimal and consistent with existing generator.
            var typeDecs = _tbMapping.PropMappings.Select(x =>
            {
                var typeDeclaration = "";
                var type = x.PropertyType;
                var nullable = " ";

                if (x.PropertyType.IsGenericType && x.PropertyType.Name == "Nullable`1")
                {
                    type = x.PropertyType.GetGenericArguments()[0];
                    nullable = " NULL ";
                }

                if (type == typeof(string)) typeDeclaration = " TEXT";
                if (type == typeof(int)) typeDeclaration = " INT";
                if (type == typeof(byte)) typeDeclaration = " SMALLINT";
                if (type == typeof(short)) typeDeclaration = " SMALLINT";
                if (type == typeof(long)) typeDeclaration = " BIGINT";
                if (type == typeof(bool)) typeDeclaration = " BOOLEAN";
                if (type == typeof(DateTime)) typeDeclaration = " TIMESTAMP";
                if (type == typeof(decimal)) typeDeclaration = " NUMERIC(18,8)";

                var colName = PopulateName(x.FieldName);

                if (x.AutoGenerate)
                {
                    // Use identity for modern PG. If you prefer SERIAL, change here.
                    typeDeclaration = " INT GENERATED BY DEFAULT AS IDENTITY";
                }

                return $"{colName} {typeDeclaration}{nullable}";
            });

            var keyFieldNames = _tbMapping.PropMappings.Where(x => x.IsKey).Select(x => PopulateName(x.FieldName));
            typeDecs = typeDecs.Append("   PRIMARY KEY(" + string.Join(",", keyFieldNames) + ")");

            return $"CREATE TABLE {TableNameForSql()} ( {string.Join(",\r\n", typeDecs.ToArray())})";
        }
    }
}
